Desafio: IngestÃ£o, curadoria e disponibilizaÃ§Ã£o de dados fictÃ­cios do Jira

PrÃ©-requisitos: realizado em Python

O objetivo deste desafio Ã© avaliar a capacidade do participante em desenvolver um pipeline de Engenharia de Dados em Python,
aplicando conceitos fundamentais como ingestÃ£o de dados, organizaÃ§Ã£o em camadas, transformaÃ§Ãµes e aplicaÃ§Ã£o de regras de
negÃ³cio. O foco principal da avaliaÃ§Ã£o serÃ¡ a correta aplicaÃ§Ã£o da Arquitetura Medallion, a clareza do cÃ³digo e a implementaÃ§Ã£o da
lÃ³gica de cÃ¡lculo de SLA.

SerÃ¡ disponibilizado um arquivo JSON contendo dados fictÃ­cios extraÃ­dos do JIRA.
CaracterÃ­sticas do data source:
- Arquivo em formato JSON
- Estrutura aninhada (listas e objetos internos)
- Dados desnormalizados
- ContÃ©m chamados com status Open, Done e Resolved

O pipeline deve ser desenvolvido seguindo a Arquitetura Medallion, organizada nas seguintes camadas:
Camada Bronze
ResponsÃ¡vel pela ingestÃ£o dos dados brutos.
Camada Silver
ResponsÃ¡vel pela limpeza e organizaÃ§Ã£o dos dados.
Camada Gold
ResponsÃ¡vel pela aplicaÃ§Ã£o das regras de negÃ³cio.


mplementaÃ§Ã£o
TransformaÃ§Ãµes:
- Leitura de arquivos JSON com estruturas aninhadas
- ManipulaÃ§Ã£o de listas e dicionÃ¡rios
- CriaÃ§Ã£o de colunas derivadas de objetos internos
- OrganizaÃ§Ã£o clara do pipeline por camadas (Bronze, Silver e Gold)
MÃ©trica â€“ SLA por Chamado
O participante deverÃ¡ calcular o tempo de resoluÃ§Ã£o de cada chamado considerando:
- Data/hora de abertura
- Data/hora de resoluÃ§Ã£o
Chamados com status Open nÃ£o possuem data de resoluÃ§Ã£o e nÃ£o devem ser considerados no cÃ¡lculo final de SLA, mas devem permanecer no 
pipeline atÃ© a camada Silver.
Regras do SLA
Prioridade | SLA esperado |
|-----------|--------------|
| High | 24 horas |
| Medium | 72 horas |
| Low | 120 horas |
O cÃ¡lculo do SLA deve considerar:
- Apenas dias Ãºteis
- ExclusÃ£o de finais de semana
- ExclusÃ£o de feriados nacionais
Para identificar feriados nacionais, deverÃ¡ ser consumida uma API pÃºblica. 
A escolha da API fica a critÃ©rio do participante.

ImplementaÃ§Ã£o da LÃ³gica de SLA
A lÃ³gica de cÃ¡lculo de SLA deve ser implementada em um arquivo Python separado (exemplo: `sla_calculation.py`).
Devem existir funÃ§Ãµes responsÃ¡veis por:
- Calcular o tempo de resoluÃ§Ã£o em horas Ãºteis
- Definir o SLA esperado de acordo com a prioridade
- Indicar se o SLA foi atendido ou violado
Espera-se o uso de estruturas bÃ¡sicas da linguagem Python, como:
- if / elif / else
- for
- FunÃ§Ãµes reutilizÃ¡veis
- ManipulaÃ§Ã£o de datas
As funÃ§Ãµes devem ser importadas e utilizadas no pipeline principal, sendo aplicadas na construÃ§Ã£o da camada Gold.

Tabela Final â€“ SLA por Chamado
A tabela final deve conter, no mÃ­nimo, os seguintes campos:
- ID do chamado
- Tipo do chamado
- Analista responsÃ¡vel
- Prioridade
- Data de abertura
- Data de resoluÃ§Ã£o
- Tempo de resoluÃ§Ã£o em horas Ãºteis
- SLA esperado (em horas)
- Indicador de SLA atendido ou nÃ£o atendido
Apenas chamados com status Done ou Resolved devem compor essa
tabela.

RelatÃ³rios Simples (ObrigatÃ³rios)
A partir da camada Gold, devem ser gerados os seguintes relatÃ³rios
agregados:
SLA MÃ©dio por Analista
- Analista
- Quantidade de chamados
- SLA mÃ©dio (em horas)
SLA MÃ©dio por Tipo de Chamado
- Tipo do chamado
- Quantidade de chamados
- SLA mÃ©dio (em horas)

Os relatÃ³rios devem ser entregues em formato 'XLSX'.

EntregÃ¡veis
- Projeto completo em Python
- Pipeline organizado por camadas (Bronze, Silver e Gold)

Diferenciais (NÃ£o ObrigatÃ³rios)
- CÃ³digo modular e reutilizÃ¡vel
- Uso de variÃ¡veis de ambiente
- UtilizaÃ§Ã£o de ambiente virtual
- HistÃ³rico de commits bem estruturado
- Tratamentos simples de qualidade de dados

PadrÃ£o de CodificaÃ§Ã£o â€“ Python

- Seguir o padrÃ£o **PEP 8**
- IndentaÃ§Ã£o com **4 espaÃ§os**
- CÃ³digo e comentÃ¡rios em **inglÃªs**
- Arquivos, funÃ§Ãµes e variÃ¡veis em **snake_case**

---

## ğŸ“ Nomes de Arquivos e Pastas

### Pastas
- Letras minÃºsculas
- `snake_case`

### Exemplos:
`src/`
`data/`
`resources/`


### Arquivos Python

Formato:
`.py`


Exemplos:
`ingest_bronze.py`
`transform_silver.py`
`build_gold.py`
`sla_calculation.py`

---
*Estrutura de exemplo: *

project-root/
â”‚
â”œâ”€â”€ data/
â”‚ â”œâ”€â”€ bronze/
â”‚ â”œâ”€â”€ silver/
â”‚ â””â”€â”€ gold/
â”‚
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ bronze/
â”‚ â”‚ â””â”€â”€ ingest_bronze.py
â”‚ â”œâ”€â”€ silver/
â”‚ â”‚ â””â”€â”€ transform_silver.py
â”‚ â”œâ”€â”€ gold/
â”‚ â”‚ â””â”€â”€ build_gold.py
â”‚ â””â”€â”€ sla_calculation.py
â”‚
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ README.md
â””â”€â”€ .gitignore

## ğŸ§© Nomes de FunÃ§Ãµes

- Devem iniciar com um **verbo**
- Nome descritivo e objetivo

Exemplos:
```python
def read_json_file():
    pass

def calculate_resolution_hours():
    pass

def check_sla_compliance():
    pass
```

ğŸ“¦ Nomes de VariÃ¡veis
- Utilizar snake_case
- Evitar nomes genÃ©ricos

Exemplos:

``issue_id``
``created_at``
``resolved_at``
``resolution_hours``
``sla_expected_hours``

ğŸ—„ï¸ Nomes de Tabelas / Arquivos de Dados
Formato:
``<camada>_<entidade>.<formato>``

### Exemplos:

``bronze_issues.json``
``silver_issues.parquet``
``gold_sla_issues.csv``

### RelatÃ³rios:

``gold_sla_by_analyst.csv``
``gold_sla_by_issue_type.csv``

###  ğŸ§¾ Nomes de Colunas
- Sempre em snake_case

- Datas devem terminar com _at ou comeÃ§ar com dt

- Campos booleanos devem iniciar com is_

Exemplos:

``issue_id``
``issue_type``
``priority``
``assignee_name``
``created_at``
``resolved_at``
``resolution_hours``
``sla_expected_hours``
``is_sla_met``

### â±ï¸ Datas e HorÃ¡rios
- Utilizar padrÃ£o ISO 8601
- Trabalhar preferencialmente em UTC

Exemplo:

``2025-01-10T08:30:00Z``